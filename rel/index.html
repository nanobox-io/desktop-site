<!DOCTYPE html><html lang=en><head><title>Nanobox</title><meta name=viewport content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0"><link rel=stylesheet href=/style.css><link href="http://fonts.googleapis.com/css?family=Lato:400,400italic" rel=stylesheet type=text/css><link rel=icon type=image/png href=/assets/favicon.png></head><body><div class=main-wrapper><div class=header><div class=logo><a href="/"><img data-src=logo-horizontal class=shadow-icon></a></div></div><div class=nav><a href=/downloads>Download</a><a class=open-community>Community</a><a href=/engines>Engines</a><a href=//dashboard.nanobox.io/users/sign_in class=sign-up>Login / Register</a></div><div class=content-area><div class=home><div class=main-summary><img data-src=top-mini-stack class=shadow-icon><div class=info><h1>Vagrant + Docker + Engines</h1><h4>Local App Environments - Automated / Lightweight / Reusable</h4><div class=links><a href="https://github.com/pagodabox?utf8=%E2%9C%93&amp;query=nanobox" class=github><img data-src=git class=shadow-icon><p>Fork me on github</p></a><a href=/downloads.html class=download><img data-src=download-home class=shadow-icon><p>Download</p></a><a href="//webchat.freenode.net/?channels=nanobox" target=_BLANK class=irc><img data-src=irc class=shadow-icon><p>IRC - #nanobox <span>(freenode)</span></p></a></div></div></div><div class=overview><div class=info><div class="blurb src-code"><h2><span>1</span>App Source Code</h2><p>Focus on coding rather than configuring a local dev environment</p></div><div class="blurb engine"><h2><span>2</span>Language Engine</h2><p>The Engine detects your app type and specifies what services your app needs (ruby, mongo, etc) and how they should be configured.</p></div><div class="blurb docker"><h2><span>3</span>Docker Containers</h2><p>Containers are configured and initialized. Your code is then built and installed.</p></div><div class="blurb vagrant"><h2><span>4</span>Vagrant / Virtual Box</h2><p>Your services run in an ultra lightweight Ubuntu virtual machine (30mb RAM). Requests to localhost are proxied to your app</p></div></div><div class=graphic><img data-src=sandwich scalable=true class=shadow-icon></div></div><div class=mini-overview><div class=mini><h2>Develop your App</h2><p>Run your code and itterate your app in a fast lightweight VM</p><div class=script><pre><code class=language-nanobox>$ nanobox up
Detecting app type
Launching Vagrant Virtual Machine
Installing runtimes in VM
etc..</code></pre></div><a href=#developing-your-app>How it works</a></div><div class=mini><h2>Run Commands</h2><p>Run generators, tests and other runtime specific scripts.</p><div class=script><pre><code class=language-nanobox>$ nanobox enter
  Entering virtual machine context:
> rake test # Run test suite</code></pre></div><a href=#developing-your-app>How it works</a></div></div><h1 id=developing-your-app>How it works <span class=sub>- Developing your App</span></h1><div class=top-blurb><span class=prompt>$</span><span class=command>nanobox</span><span class=param>up</span> : creates a virtual staging environment and installs everything your code needs to run. As you edit your code, your files are compiled on and copied into your running container. The following is a breakdown of what nanobox is doing behind the scenes:</div><div class=row><div class=descript><h2><span>1</span>Vagrant initializes</h2><p>Nanobox uses Vagrant to launch a virtual machine running a custom operating system with all the necessary Docker and Nanobox bits installed and running at boot. The Vagrantfile is configured to mount the code directory inside the virtual machine as a shared directory.</p></div><div class="visual vagrant-init"><img data-src=vagrant-initializes scalable=true class=shadow-icon></div></div><div class=row><div class=descript><h2><span>2</span>Nanobox daemon initializes</h2><p>After the virtual machine boots, a Nanobox api daemon is spawned and waits to receive commands from the nanobox client.</p></div><div class="visual nanobox-daemon"><img data-src=nanobox-initializes scalable=true class=shadow-icon></div></div><div class=row><div class=descript><h2><span>3</span>A build container is launched and your Code is copied into the container</h2><p>The client tells the api daemon to start a deploy process which launches a Docker container used to build, prepare, and package your code. Once the container is up and running, the code from your workstation is rsync’d into the container. Copying the code prevents the build process from modifying your codebase directly.</p></div><div class="visual vagrant-init"><img data-src=build-cont-launches scalable=true class=shadow-icon></div></div><div class=row><div class=descript><h2><span>4</span>Each Engine sniffs the code looking for a positive match to determine which language / framework your app is written in</h2><p>A registry of Engines sniff your code to determine if you are using a known framework. The build process is custom-tailored to optimally configure the environment for that framework. eg: install and configure runtimes and services such as ruby, node.js, PostgreSQL, MySQL, etc..</p></div><div class="visual engine-sniff"><img data-src=framework-sniff scalable=true class=shadow-icon></div></div><div class=row><div class=descript><h2><span>5</span>The matched Engine generates a Boxfile defining the services your app needs to run and how each should be configured</h2><p>The Engine determines which services your app depends on. It can analyze the codebase to determine dependencies, or it might already know what is needed. As service dependencies are determined, a Boxfile is generated that informs Nanobox which services to launch and how to configure them. These services might include redis, postgres, memcache, mysql, or other data-specific services.</p></div><div class="visual boxfile"><img data-src=boxfile scalable=true class=shadow-icon></div></div><div class=row><div class=descript><h2><span>6</span>Nanobox launches and configures Docker containers specified in the Boxfile</h2><p>The Boxfile in the codebase and the Boxfile from the Engine are merged. Nanobox launches and configures a Docker container for each service specified in the merged Boxfile. Nanobox overlays a private network with custom IP addresses on a native tcp stack through which the containers can communicate.</p></div><div class="visual launch-containers"><img data-src=docker-containers scalable=true class=shadow-icon></div></div><div class=row><div class=descript><h2><span>7</span>Code is built and installed into code containers and the build container is decommissioned</h2><p>In the build container, your code is compiled and prepared to run. The Engine generates or modifies config files that allow your app to communicate with the provisioned services. In some cases, the Engine will modify source code, if necessary, to adjust service connection details or ensure a legacy app is suited for a distributed architecture. With the build complete, the output is dropped into another container which runs your app.</p></div><div class="visual build-code"><img data-src=code-built scalable=true class=shadow-icon></div></div><div class=row><div class=descript><h2><span>8</span>A router is launched to proxy localhost requests to your app</h2><p>A router is launched to proxy requests from your workstation into the container hosting your finalized app. For simplicity, a DNS entry is added to your workstation. Your app is launched and ready for development iteration.</p></div><div class="visual router"><img data-src=proxy-router scalable=true class=shadow-icon></div></div><div class=row><div class=descript><h2><span>9</span>If files are watched, local saves will run steps 3-8 automatically</h2><p>With your development environment up and running, you can refresh the build at any time. If you started your Nanobox with --watch, any file changes within your code will automatically trigger a rebuild. After the initial build, assets are cached between deploys making subsequent builds really quick.</p></div><div class="visual watch"><img data-src=watched-files scalable=true class=shadow-icon></div></div><h1>Create an engine for your framework</h1><div class="row first engine-blurb"><div class=visual><img data-src=mad-scientist-window scalable=true class=shadow-icon></div><div class=descript><h2>It’s your framework, you define the ideal runtime</h2><p>You specify the services your framework needs and how they should be configured so devs can begin building their app immediately with no need to install or configure anything.</p><a href="/index.html?page=engines" class=inline>Get started<img data-src=right-arrow class=shadow-icon></a></div></div><h1 id=running-commands class=running-commands>How it works <span class=sub>- Running Commands</span></h1><div class="top-blurb running-commands"><span class=prompt>$</span><span class=command>nanobox</span><span class=param>up</span> : creates a virtual staging environment and installs everything your code needs to run. As you edit your code, your files are compiled and copied into your running container. The following is a breakdown of what nanobox is doing behind the scenes:</div><div class="row running-commands"><div class=descript><h2><span>1</span>Vagrant initializes</h2><p>Nanobox uses Vagrant to launch a virtual machine running a custom operating system with all the necessary Docker and Nanobox bits installed and running at boot. The Vagrantfile is configured to mount the code directory inside the virtual machine as a shared directory.</p></div><div class="visual vagrant-init"><img data-src=vagrant-initializes scalable=true class=shadow-icon></div></div></div></div></div><script src=js/libs.js></script><script>try{Typekit.load();}catch(e){}</script><script src=/js/app.js></script></body></html>